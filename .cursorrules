# Music Plugin Organizer - Development Rules

## Agent Workflow System

This project uses a 5-agent cascade workflow. Each agent has specific responsibilities and cannot proceed without completing their blockers.

### Available Agents
- **@designer** - Requirements clarification, ADRs, branch creation, pushback on unclear ideas
- **@coder** - Implementation following the design
- **@tester** - Test coverage (80%+ on new code)
- **@documenter** - Documentation for all code files
- **@closer** - Final validation, formatting, PR creation, GitHub issues for gaps

### Agent Definitions
Full agent definitions with personalities, blockers, and handoff templates are in:
- `.cursor/agents/designer.md`
- `.cursor/agents/coder.md`
- `.cursor/agents/tester.md`
- `.cursor/agents/documenter.md`
- `.cursor/agents/closer.md`

### Workflow Documentation
See `.cursor/WORKFLOW.md` for the complete workflow guide.

### Feature Folder Structure
Each feature gets its own folder with per-agent documents:
```
.cursor/features/active/<feature-name>/
‚îú‚îÄ‚îÄ README.md        # Feature tracking
‚îú‚îÄ‚îÄ designer.md      # Requirements, ADR ref, coder prompt
‚îú‚îÄ‚îÄ coder.md         # Implementation notes, tester prompt
‚îú‚îÄ‚îÄ tester.md        # Test summary, documenter prompt
‚îú‚îÄ‚îÄ documenter.md    # Doc summary, closer prompt
‚îî‚îÄ‚îÄ closer.md        # PR link, issues created
```

## üö® Critical Git Rules

**AGENTS NEVER MERGE TO MAIN LOCALLY**

- ‚úÖ Always work on feature branches (`feature/name`)
- ‚úÖ Push branches to GitHub
- ‚úÖ Create PRs on GitHub
- ‚úÖ Merge through GitHub's interface
- ‚ùå NEVER `git checkout main && git merge`
- ‚ùå NEVER `git push origin main` directly

**Why?** Code review, CI/CD validation, traceability, branch protection, and team collaboration.

## Self-Documenting Architecture

### Core Principle
Every module must document itself. Code and documentation are updated together, never separately.

### Documentation Requirements

#### Every Component/Hook/Store Must Have:
1. **Corresponding .md file** in the same directory
2. **JSDoc comments** for all exported functions/components
3. **TypeScript types** for all props, parameters, and return values
4. **Usage examples** in the .md file

#### .md File Structure
Each .md file must contain:
```markdown
# [Component/Hook/Store Name]

**Last Updated:** [YYYY-MM-DD] - [Reason for update]

## Purpose
[What it does and why it exists]

## Dependencies
- [List of imports and what they're used for]

## Props/API
[TypeScript interface with descriptions]

## Usage Example
[Code example showing how to use it]

## State Management
[What state it manages and how]

## Related Components
[What it connects to or works with]

## Future Enhancements
[Planned improvements]
```

### File Size Limits
- **Components:** <250 lines (split if larger)
- **Hooks:** <150 lines (split if larger)
- **Stores:** <300 lines (split if larger)
- **Utilities:** <200 lines (split if larger)

If exceeding limits, refactor into smaller, focused modules.

### Code Quality Standards

#### TypeScript
- **Strict mode enabled** - no `any` types without justification
- **Explicit return types** for all functions
- **Interface over type** for object shapes
- **Enums for constants** with multiple related values

#### React
- **Functional components only** - no class components
- **Custom hooks** for reusable logic
- **Memoization** for expensive computations
- **Proper dependency arrays** in useEffect/useMemo/useCallback

#### Naming Conventions
- **Components:** PascalCase (e.g., `InstrumentNode.tsx`)
- **Hooks:** camelCase with `use` prefix (e.g., `useKeyboardShortcuts.ts`)
- **Stores:** camelCase with `Store` suffix (e.g., `instrumentStore.ts`)
- **Utilities:** camelCase (e.g., `formatDate.ts`)
- **Types:** PascalCase (e.g., `Instrument`, `Template`)
- **Constants:** UPPER_SNAKE_CASE (e.g., `MAX_INSTRUMENTS`)

### Before Committing

#### Required Checks:
1. ‚úÖ Run `npm run docs:validate` - ensures all files have documentation
2. ‚úÖ Run `npm run type-check` - TypeScript compilation succeeds
3. ‚úÖ Run `npm run lint` - ESLint passes
4. ‚úÖ Update CHANGELOG.md - for user-facing changes
5. ‚úÖ Update architecture docs - for architectural changes

#### Git Commit Message Format:
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat` - New feature
- `fix` - Bug fix
- `docs` - Documentation only
- `style` - Code style changes (formatting)
- `refactor` - Code refactoring
- `test` - Adding tests
- `chore` - Build process or auxiliary tool changes

**Examples:**
```
feat(canvas): add zoom to fit selected nodes

Implements zoom animation when user selects multiple nodes
and presses Ctrl+F. Uses React Flow's fitView with padding.

Closes #42
```

```
docs(instrument-node): update usage examples

Added examples for custom styling and event handling.
Updated props documentation with new optional fields.
```

### Architecture Decision Records (ADRs)

#### When to Create an ADR:
- Choosing between significant technical alternatives
- Making decisions that affect multiple components
- Introducing new patterns or paradigms
- Changing existing architectural patterns

#### ADR Format:
```markdown
## ADR-XXX: [Decision Title]

**Date:** YYYY-MM-DD
**Status:** [Proposed | Accepted | Deprecated | Superseded]

### Context
[The situation and problem]

### Decision
[What we decided to do]

### Rationale
[Why we made this decision]

### Consequences
- **Positive:** [Benefits]
- **Negative:** [Drawbacks]
- **Mitigation:** [How we address drawbacks]

### Alternatives Considered
[Other options we evaluated]
```

Add ADRs to `docs/architecture/decisions.md`

### Component Development Workflow

#### Creating a New Component:

1. **Plan First:**
   - What problem does it solve?
   - What are its dependencies?
   - What state does it need?
   - How will it be tested?

2. **Create Files:**
   ```
   ComponentName.tsx
   ComponentName.md
   ComponentName.test.tsx (if complex logic)
   ```

3. **Implement:**
   - Write TypeScript interface first
   - Add JSDoc comments
   - Implement component
   - Add usage example to .md

4. **Document:**
   - Fill out all sections of .md file
   - Update related component docs
   - Update architecture docs if needed

5. **Validate:**
   - Run `npm run docs:validate`
   - Run `npm run type-check`
   - Test the component

### Store Development Workflow

Stores use Zustand and follow this pattern:

```typescript
/**
 * [Store Name] Store
 * 
 * [Description of what this store manages]
 */

interface [StoreName]State {
  // State properties
  items: Item[];
  
  // Actions
  addItem: (item: Item) => void;
  removeItem: (id: string) => void;
  updateItem: (id: string, updates: Partial<Item>) => void;
}

export const use[StoreName]Store = create<[StoreName]State>()(
  persist(
    (set, get) => ({
      // Initial state
      items: [],
      
      // Actions
      addItem: (item) => set((state) => ({
        items: [...state.items, item]
      })),
      
      // ... more actions
    }),
    {
      name: '[store-name]-storage',
    }
  )
);
```

### UI Component Guidelines

#### shadcn/ui Components (in `src/components/ui/`)
- **Do not modify** unless absolutely necessary
- **Do not add .md files** - these are third-party components
- If customization needed, create wrapper component

#### Custom Components
- **Always document** with .md file
- **Use shadcn/ui primitives** when possible
- **Follow accessibility guidelines** (ARIA labels, keyboard navigation)
- **Support dark theme** (use Tailwind dark: variants)

### Testing Strategy

#### Unit Tests (Future):
- Complex business logic
- Utility functions
- Custom hooks

#### Integration Tests (Future):
- Component interactions
- Store operations
- Canvas operations

#### E2E Tests (Future):
- Critical user flows
- Cross-platform compatibility

### Performance Guidelines

#### React Performance:
- Use `useMemo` for expensive computations
- Use `useCallback` for event handlers passed to children
- Use `React.memo` for components that re-render frequently
- Avoid inline object/array creation in render

#### Canvas Performance:
- Limit visible nodes (React Flow handles this)
- Memoize node data transformations
- Debounce search/filter operations
- Use virtual scrolling for large lists

### Accessibility Requirements

- **Keyboard navigation** for all interactive elements
- **ARIA labels** for icon buttons
- **Focus indicators** visible and clear
- **Color contrast** meets WCAG AA standards
- **Screen reader support** for critical features

### Error Handling

#### User-Facing Errors:
- Show toast notifications for errors
- Provide actionable error messages
- Log errors to console for debugging

#### Development Errors:
- Throw errors early for invalid states
- Use TypeScript to prevent type errors
- Add runtime validation for external data

### Security Considerations

- **No sensitive data** in localStorage (future: encrypt if needed)
- **Sanitize file paths** from directory scanner
- **Validate imported data** structure
- **No eval() or dangerous patterns**

### Future-Proofing

#### Planned Migrations:
- **Phase 2:** IndexedDB for larger datasets
- **Phase 3:** Electron IPC for file system operations
- **Phase 4:** Plugin scanning automation
- **Phase 5:** Cloud sync (optional)

Keep these in mind when making architectural decisions.

### Agent-Specific Instructions

**See full agent definitions in `.cursor/agents/` for complete details.**

#### @designer Agent:
1. Ask probing questions - push back on vague requirements
2. Create/update ADR in `docs/architecture/decisions.md`
3. Set up clean branch from latest main
4. Create designer handoff with @coder prompt
5. **Blockers:** Cannot proceed without ADR and clean branch

#### @coder Agent:
1. Follow the designer's plan exactly
2. Make atomic commits with conventional messages
3. Pass type-check and lint before completing
4. Create coder handoff with @tester prompt
5. **Blockers:** Cannot proceed without passing quality checks

#### @tester Agent:
1. Write tests for all new code files
2. Achieve 80%+ coverage on new code
3. Test behavior, not implementation details
4. Create tester handoff with @documenter prompt
5. **Blockers:** Cannot proceed without passing tests and coverage

#### @documenter Agent:
1. Create .md file for every new code file
2. Update architecture docs if needed
3. Include working examples
4. Create documenter handoff with @closer prompt
5. **Blockers:** Cannot proceed without all docs created

#### @closer Agent:
1. Run `npm run pre-push` - all checks must pass
2. Run `npm run format` - format all code
3. Create GitHub issues for any gaps (`npm run create-issue`)
4. Push branch and create PR
5. Create closer handoff with PR link
6. **NEVER merge to main locally** - always use GitHub

### Quick Reference

#### Common Commands:
```bash
# Development
npm run dev                 # Start development server
npm run electron:dev        # Start Electron app

# Feature Workflow
npm run feature:start       # Start new feature (branch + folder)
npm run feature:complete    # Archive completed feature

# Quality Checks
npm run pre-push            # Run ALL quality checks
npm run validate:branch     # Validate branch naming
npm run docs:validate       # Check documentation completeness
npm run type-check          # Run TypeScript compiler
npm run lint                # Run ESLint
npm run format              # Format code with Prettier

# GitHub Integration
npm run create-issue        # Create GitHub issue for gaps

# Testing
npm test                    # Run tests
npm run test:coverage       # Run tests with coverage

# Build
npm run build               # Build for production
```

#### File Locations:
- Components: `src/components/`
- Hooks: `src/hooks/`
- Stores: `src/store/`
- Types: `src/types/`
- Utils: `src/lib/`
- Architecture docs: `docs/architecture/`
- Scripts: `scripts/`

### Questions to Ask Before Coding

1. **Does this already exist?** Check existing components/hooks
2. **Is this the right place?** Verify file organization
3. **What are the dependencies?** Minimize coupling
4. **How will this scale?** Consider performance
5. **Is this testable?** Design for testability
6. **Is this documented?** Plan documentation structure

---

## Summary

**Remember:** Code and documentation are created together. If you write code without documentation, it doesn't exist. If you write documentation without updating code, it's wrong. They are one.

**Goal:** In 6 months, any agent (or human) should be able to understand any part of this codebase by reading the .md files and architecture docs.

